### 题目描述

给定一个整数数组 `nums` 和一个整数目标值 `target`，请你在该数组中找出 **和为目标值** 的那 **两个** 整数，并返回它们的数组下标。

**假设条件**：
- 每种输入只会对应一个答案。
- 不能使用两次相同的元素。
- 你可以按任意顺序返回答案。

**示例**：
- 输入：`nums = [2,7,11,15], target = 9`
- 输出：`[0,1]`
- 解释：因为 `nums[0] + nums[1] == 9`，所以返回 `[0, 1]`。

### 我的答案

```cpp
vector<int> twoSum(vector<int>& nums, int target) {
    vector<int> res;
    unordered_map<int, int> hash;
    for (int i = 0; i < nums.size(); i++) {
        int num = nums[i];
        int diff = target - num;
        if (hash.find(diff) != hash.end()) {
            res.push_back(hash[diff]);
            res.push_back(i);
            return res;
        }
        hash[num] = i;
    }
    return res;
}
```

### 详细解释

这个算法的核心思想是利用哈希表来存储已经遍历过的元素及其对应的下标，以便于在后续的遍历中快速查找是否存在一个元素，使得它与当前元素的和等于 `target`。

**具体步骤**：
1. 创建一个空的 `unordered_map<int, int>` 对象 `hash`，用于存储数组中的元素及其对应的下标。
2. 遍历数组 `nums`，对于每一个元素 `nums[i]`：
   - 计算 `diff = target - nums[i]`，即需要在数组中找到的与 `nums[i]` 相加等于 `target` 的元素。
   - 使用 `hash.find(diff)` 查找 `diff` 是否已经存在于 `hash` 中：
     - 如果存在，说明找到了两个数的和等于 `target`，此时将 `hash[diff]` 和 `i` 添加到结果 `res` 中并返回 `res`。
     - 如果不存在，将当前元素 `nums[i]` 和它的下标 `i` 存入 `hash` 中。
3. 如果遍历结束后仍未找到符合条件的两个数，返回空的结果 `res`。

**示例说明**：
- 假设 `nums = [2,7,11,15], target = 9`，初始时 `hash` 为空。
- 遍历到第一个元素 `2`，计算 `diff = 9 - 2 = 7`，`7` 不在 `hash` 中，将 `2` 存入 `hash`，此时 `hash = {2:0}`。
- 遍历到第二个元素 `7`，计算 `diff = 9 - 7 = 2`，`2` 存在于 `hash` 中，返回 `[hash[2], 1] = [0, 1]`。

### 解题思路

这道题的核心是**查找问题**，即如何在数组中快速找到一个与当前元素相加等于 `target` 的元素。为了实现快速查找，可以使用哈希表来存储已经遍历过的元素及其下标。哈希表的特点是查找操作的时间复杂度为 `O(1)`，因此可以大大提高算法的效率。

**哈希表的选择**：
在C++中，常用的哈希表结构有 `std::map`、`std::unordered_map` 和 `std::multimap`。其中：
- `std::map` 和 `std::multimap` 底层使用红黑树实现，查找时间复杂度为 `O(log n)`。
- `std::unordered_map` 使用哈希表实现，查找时间复杂度为 `O(1)`，因此在需要频繁查找的场景下，`unordered_map` 是更好的选择。

### 补充知识

#### 哈希表的原理

哈希表是一种基于数组的数据结构，通过哈希函数将键（key）映射到数组的某个位置（即索引），从而实现快速查找、插入和删除操作。

**哈希函数**的作用是将任意长度的输入（如字符串、数字等）映射到固定长度的输出（通常是一个整数），这个输出就是哈希值。

**哈希冲突**：由于哈希函数的输出空间是有限的，而输入空间可能是无限的，因此可能会出现两个不同的输入映射到同一个哈希值的情况，这就是哈希冲突。解决哈希冲突的常见方法有：
- **开放寻址法**：当发生冲突时，尝试在数组的其他位置（如下一个位置）存储冲突的元素。
- **链地址法**：每个数组位置存储一个链表，所有哈希值相同的元素都存储在该链表中。

#### 哈希表与数组的区别

- **数组**：数组的索引是连续的整数，存储地址与索引直接相关。
- **哈希表**：哈希表的索引是通过哈希函数计算得到的，存储地址与索引是通过哈希函数间接关联的，索引的范围取决于哈希函数的输出范围。

#### 哈希函数的特点

1. **不可逆性**：哈希函数是单向的，即从哈希值无法反推出原始输入。
2. **一致性**：相同的输入总是映射到相同的哈希值。
3. **均匀性**：不同的输入应该尽可能均匀地分布在哈希表的不同位置，以减少冲突的发生。

#### 常见的哈希算法

- **MD5**：生成128位的哈希值，但由于存在碰撞问题，安全性较低。
- **SHA-1**：生成160位的哈希值，安全性高于MD5，但仍存在碰撞问题。
- **SHA-2**：包括SHA-224、SHA-256、SHA-384和SHA-512，安全性较高。

这些哈希算法通常用于生成数据的摘要（digest），以确保数据的完整性和一致性。

### 总结

这道题目通过使用哈希表解决了在数组中查找两个数之和等于目标值的问题。哈希表的快速查找特性使得算法的时间复杂度降低到 `O(n)`，其中 `n` 是数组的长度。通过理解哈希表的原理和特性，可以更好地解决类似的查找问题。
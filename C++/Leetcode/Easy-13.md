### 题目描述

给定一个罗马数字字符串 `s`，将其转换为整数。罗马数字包含以下七种字符：I，V，X，L，C，D 和 M。

| 字符 | 数值  |
|------|-------|
| I    | 1     |
| V    | 5     |
| X    | 10    |
| L    | 50    |
| C    | 100   |
| D    | 500   |
| M    | 1000  |

**特殊规则**：
- I 可以放在 V (5) 和 X (10) 的左边，来表示 4 和 9。
- X 可以放在 L (50) 和 C (100) 的左边，来表示 40 和 90。
- C 可以放在 D (500) 和 M (1000) 的左边，来表示 400 和 900。

**示例**：
- 输入: `s = "III"`
- 输出: `3`
- 解释: III 表示 1 + 1 + 1 = 3。

- 输入: `s = "IV"`
- 输出: `4`
- 解释: IV 表示 5 - 1 = 4。

- 输入: `s = "IX"`
- 输出: `9`
- 解释: IX 表示 10 - 1 = 9。

- 输入: `s = "LVIII"`
- 输出: `58`
- 解释: L = 50, V = 5, III = 3，所以 LVIII 表示 50 + 5 + 3 = 58。

- 输入: `s = "MCMXCIV"`
- 输出: `1994`
- 解释: M = 1000, CM = 900, XC = 90, IV = 4，所以 MCMXCIV 表示 1000 + 900 + 90 + 4 = 1994。

### 我的答案

```cpp
int romanToInt(string s) {
    int length = s.size();
    int sum = 0;
    std::unordered_map<char, int> roman_map = {
        {'I', 1}, {'V', 5}, {'X', 10}, {'L', 50},
        {'C', 100}, {'D', 500}, {'M', 1000}
    };

    for (int i = 0; i < length; i++) {
        if (i + 1 < length && roman_map[s[i]] < roman_map[s[i + 1]]) {
            sum -= roman_map[s[i]];
        } else {
            sum += roman_map[s[i]];
        }
    }
    return sum;
}
```

### 详细解释

这个算法的核心思想是通过逐个字符遍历罗马数字字符串，并根据当前字符和下一个字符的数值关系来决定是加法还是减法。

**具体步骤**：
1. **初始化**：
   - 创建一个 `unordered_map` 来存储罗马字符与其对应的整数值。
   - 初始化 `sum` 为 0，用于存储最终的整数值。

2. **遍历字符串**：
   - 对于每个字符 `s[i]`，检查它与下一个字符 `s[i+1]` 的大小关系：
     - 如果 `roman_map[s[i]] < roman_map[s[i+1]]`，说明当前字符需要减去（如 `IV` 中的 `I`）。
     - 否则，直接将当前字符的值加到 `sum` 中。

3. **返回结果**：
   - 遍历结束后，返回 `sum`。

**示例说明**：
- 对于输入 `s = "MCMXCIV"`：
  - 遍历到 `M`，加 1000。
  - 遍历到 `C`，比较 `C` 和 `M`，`C < M`，减 100。
  - 遍历到 `M`，加 1000。
  - 遍历到 `X`，比较 `X` 和 `C`，`X < C`，减 10。
  - 遍历到 `C`，加 100。
  - 遍历到 `I`，比较 `I` 和 `V`，`I < V`，减 1。
  - 遍历到 `V`，加 5。
  - 最终结果为 1000 + (-100) + 1000 + (-10) + 100 + (-1) + 5 = 1994。

### 解题思路

#### 我的思路

- **左>右 做加法，右>左 做减法，最后一个字符直接加**：
  - 这个规则是基于罗马数字的编码规则得出的。通常情况下，罗马数字中小的数字在大的数字的右边，表示加法；但当小的数字在大的数字的左边时，表示减法。

#### 优化思路

- **时间复杂度**：逐个字符遍历字符串，时间复杂度为 `O(n)`，其中 `n` 是字符串的长度。
- **空间复杂度**：使用了一个 `unordered_map` 来存储字符对应的数值，空间复杂度为 `O(1)`，因为字符数量是固定的。

#### 我的答案与官方答案的比较

- **时间复杂度**：我的答案和官方答案的时间复杂度相同，均为 `O(n)`。
- **空间复杂度**：我的答案和官方答案的空间复杂度也相同，均为 `O(1)`。
- **无意义的比较**：我的答案避免了多余的比较，每次只比较当前字符和下一个字符的关系，没有进行无意义的比较。

### 具体实现

**逐字符遍历法的实现**：
- **初始化**：
  - 使用 `unordered_map` 存储罗马字符与其对应的整数值。
- **遍历字符串**：
  - 对于每个字符 `s[i]`，根据它与下一个字符 `s[i+1]` 的大小关系决定加法或减法。
- **返回结果**：
  - 遍历结束后，返回 `sum`。

### 补充知识

#### 罗马数字的编码规则

- **基本字符**：I，V，X，L，C，D，M 分别表示 1，5，10，50，100，500，1000。
- **特殊规则**：
  - I 放在 V 和 X 的左边表示 4 和 9。
  - X 放在 L 和 C 的左边表示 40 和 90。
  - C 放在 D 和 M 的左边表示 400 和 900。

#### 逐字符遍历法的优点

- **时间复杂度低**：逐字符遍历的时间复杂度为 `O(n)`，其中 `n` 是字符串的长度。
- **空间复杂度低**：只使用了常数级别的额外空间。

### 总结

逐字符遍历法是一种高效地将罗马数字转换为整数的方法，避免了字符串转换的空间开销。通过逐个字符遍历并根据字符之间的关系进行加减操作，可以在 `O(n)` 的时间复杂度内完成转换。对于优化，可以考虑使用数组代替哈希表，进一步减少空间开销。
### 题目描述

编写一个函数来查找字符串数组中的最长公共前缀。如果不存在公共前缀，返回空字符串 `""`。

**示例**：
- 输入：`strs = ["flower","flow","flight"]`
- 输出：`"fl"`
- 解释：最长公共前缀是 `"fl"`。

- 输入：`strs = ["dog","racecar","car"]`
- 输出：`""`
- 解释：输入的字符串没有公共前缀。

### 我的答案

```cpp
string longestCommonPrefix(vector<string>& strs) {
    if (strs.empty()) return "";
  
    std::string result;
    for (int i = 0; i < strs[0].size(); i++) {
        char c = strs[0][i];
        for (int j = 1; j < strs.size(); j++) {
            if (i >= strs[j].size() || strs[j][i] != c) {
                return result;
            }
        }
        result += c;
    }
    return result;
}
```

### 详细解释

这个算法的核心思想是通过逐个字符比较字符串数组中的每个字符串，找到它们的最长公共前缀。

**具体步骤**：
1. **初始化**：
   - 如果输入的字符串数组为空，直接返回空字符串 `""`。
   - 初始化一个空字符串 `result`，用于存储最长公共前缀。

2. **逐字符比较**：
   - 对于第一个字符串 `strs[0]` 的每个字符 `strs[0][i]`：
     - 遍历字符串数组中的其他字符串 `strs[j]`，检查它们的第 `i` 个字符是否与 `strs[0][i]` 相同。
     - 如果某个字符串的第 `i` 个字符不存在（即 `i >= strs[j].size()`）或者不匹配 `strs[0][i]`，则直接返回当前的 `result`。

3. **更新结果**：
   - 如果所有字符串的第 `i` 个字符都匹配，则将该字符添加到 `result` 中。

4. **返回结果**：
   - 遍历结束后，返回 `result`。

**示例说明**：
- 对于输入 `strs = ["flower","flow","flight"]`：
  - 比较第一个字符 `f`，所有字符串都匹配，`result = "f"`。
  - 比较第二个字符 `l`，所有字符串都匹配，`result = "fl"`。
  - 比较第三个字符 `o`，`"flight"` 的第三个字符是 `i`，不匹配，直接返回 `result = "fl"`。

### 解题思路

#### 我的思路

- **纵向扫描法**：
  - 逐个字符比较字符串数组中的每个字符串，找到它们的最长公共前缀。
  - 如果某个字符不匹配或某个字符串的长度不足，则直接返回当前的 `result`。

#### 官方建议的思路

**1. 横向扫描法（递归查找法）**：
- 定义一个函数 `lcp(str1, str2)` 来求两个字符串的公共前缀。
- 然后遍历字符串数组，依次求两个字符串的公共前缀。
- **时间复杂度**：`O(mn)`，其中 `m` 是字符串的平均长度，`n` 是字符串的数量。
- **空间复杂度**：`O(1)`。

**2. 纵向扫描法**：
- 与我的答案类似，逐个字符比较字符串数组中的每个字符串。
- **时间复杂度**：`O(mn)`，其中 `m` 是字符串的平均长度，`n` 是字符串的数量。
- **空间复杂度**：`O(1)`。

**3. 分治法**：
- 将字符串数组分成两部分，分别求两部分的公共前缀，然后求这两个公共前缀的公共前缀。
- **时间复杂度**：`O(mn)`，其中 `m` 是字符串的平均长度，`n` 是字符串的数量。
- **空间复杂度**：`O(mlogn)`，因为递归调用需要额外的栈空间。

**4. 二分查找法**：
- 在 `[0, minLength]` 范围内进行二分查找，`minLength` 是最短字符串的长度。
- 每次二分查找一个可能的公共前缀长度，然后验证是否所有字符串都有这个前缀。
- **时间复杂度**：`O(mnlogm)`，其中 `m` 是字符串的平均长度，`n` 是字符串的数量。
- **空间复杂度**：`O(1)`。

#### 我的答案与官方答案的比较

- **时间复杂度**：我的答案和官方的纵向扫描法、横向扫描法、分治法的时间复杂度均为 `O(mn)`，其中 `m` 是字符串的平均长度，`n` 是字符串的数量。
- **空间复杂度**：我的答案和官方的纵向扫描法、横向扫描法的空间复杂度均为 `O(1)`，而分治法的空间复杂度为 `O(mlogn)`。
- **无意义的比较**：我的答案避免了多余的比较，每次只比较当前字符和下一个字符的关系，没有进行无意义的比较。

### 具体实现

**纵向扫描法的实现**：
- **初始化**：
  - 使用一个空字符串 `result` 存储最长公共前缀。
- **逐字符比较**：
  - 对于第一个字符串 `strs[0]` 的每个字符 `strs[0][i]`，遍历其他字符串 `strs[j]`，检查它们的第 `i` 个字符是否匹配。
- **返回结果**：
  - 遍历结束后，返回 `result`。

### 补充知识

#### 最长公共前缀的定义

最长公共前缀是指多个字符串中，从第一个字符开始，连续相同的部分。例如，`["flower","flow","flight"]` 的最长公共前缀是 `"fl"`。

#### 纵向扫描法的优点

- **时间复杂度低**：纵向扫描法的时间复杂度为 `O(mn)`，其中 `m` 是字符串的平均长度，`n` 是字符串的数量。
- **空间复杂度低**：只使用了常数级别的额外空间。

#### 纵向扫描法的缺点

- **代码复杂度较高**：需要处理字符之间的关系，代码较为复杂。
- **可能存在边界条件**：对于最后一个字符，需要特殊处理，避免越界访问。

#### 优化建议

- **提前终止**：可以在遍历过程中提前终止，避免不必要的遍历。
- **使用分治法**：可以通过分治法进一步优化，减少比较次数。

### 总结

纵向扫描法是一种高效地找到字符串数组中最长公共前缀的方法。通过逐个字符比较字符串数组中的每个字符串，可以在 `O(mn)` 的时间复杂度内完成查找。对于优化，可以考虑使用分治法进一步减少比较次数。
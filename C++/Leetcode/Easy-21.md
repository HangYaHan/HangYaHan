### 题目描述

给定两个升序链表 `l1` 和 `l2`，将它们合并为一个新的升序链表并返回。新链表是通过拼接给定的两个链表的所有节点组成的。

**示例**：
- 输入：`l1 = [1,2,4]`, `l2 = [1,3,4]`
- 输出：`[1,1,2,3,4,4]`
- 解释：合并后的链表为 `[1,1,2,3,4,4]`。

- 输入：`l1 = []`, `l2 = []`
- 输出：`[]`
- 解释：两个链表都为空，合并后的链表也为空。

- 输入：`l1 = []`, `l2 = [0]`
- 输出：`[0]`
- 解释：链表 `l1` 为空，直接返回链表 `l2`。

### 解题思路

#### 暴力解法

**思路**：
- 使用一个临时指针 `pre` 指向当前的节点。
- 使用一个哑节点 `dummy` 来处理边界问题，哑节点的值可以设为 `-1`，它的 `next` 指针指向合并后的链表的头节点。
- 使用三个指针：`prepre`（指向哑节点）、`pre`（指向当前节点）、`l1` 和 `l2`。
- 每次比较 `l1` 和 `l2` 的值，取较小的那个节点，将其连接到 `pre` 的 `next`，然后推进 `pre` 和较小的那个链表的指针。
- 当 `l1` 或 `l2` 为空时，将剩余的链表连接到 `pre` 的 `next`。
- 最后返回哑节点的 `next`，即合并后的链表。

**时间复杂度**：
- 时间复杂度为 `O(m + n)`，其中 `m` 和 `n` 分别是两个链表的长度。
- 因为每个节点最多只被访问一次。

**空间复杂度**：
- 空间复杂度为 `O(1)`，只使用了常数级别的额外空间。

#### 递归法

**思路**：
- 递归地合并两个链表。
- 如果 `l1` 的值小于 `l2` 的值，那么 `l1` 的 `next` 指向递归合并后的 `l1->next` 和 `l2`。
- 否则，`l2` 的 `next` 指向递归合并后的 `l1` 和 `l2->next`。
- 递归的终止条件是其中一个链表为空，返回另一个链表。

**时间复杂度**：
- 时间复杂度为 `O(m + n)`，其中 `m` 和 `n` 分别是两个链表的长度。
- 因为每个节点最多只被访问一次。

**空间复杂度**：
- 空间复杂度为 `O(m + n)`，递归调用的栈深度为 `m + n`。

#### 比较

- **时间复杂度**：两种方法的时间复杂度均为 `O(m + n)`。
- **空间复杂度**：
  - 暴力解法的空间复杂度为 `O(1)`。
  - 递归法的空间复杂度为 `O(m + n)`。
- **无意义的比较**：两种方法都没有进行无意义的比较，每次比较都是必要的。

### 具体实现

#### 暴力解法实现

```cpp
struct ListNode {
    int val;
    ListNode *next;
    ListNode() : val(0), next(nullptr) {}
    ListNode(int x) : val(x), next(nullptr) {}
    ListNode(int x, ListNode *next) : val(x), next(next) {}
};

ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
    ListNode* dummy = new ListNode(-1);
    ListNode* pre = dummy;
  
    while (l1 != nullptr && l2 != nullptr) {
        if (l1->val < l2->val) {
            pre->next = l1;
            l1 = l1->next;
        } else {
            pre->next = l2;
            l2 = l2->next;
        }
        pre = pre->next;
    }
  
    if (l1 != nullptr) {
        pre->next = l1;
    } else {
        pre->next = l2;
    }
  
    return dummy->next;
}
```

#### 递归法实现

```cpp
ListNode* mergeTwoLists(ListNode* l1, ListNode* l2) {
    if (l1 == nullptr) {
        return l2;
    }
    if (l2 == nullptr) {
        return l1;
    }
  
    if (l1->val < l2->val) {
        l1->next = mergeTwoLists(l1->next, l2);
        return l1;
    } else {
        l2->next = mergeTwoLists(l1, l2->next);
        return l2;
    }
}
```

### 补充知识

#### 链表相关知识

- **链表**：
  - 链表是一种线性数据结构，由一系列节点组成，每个节点包含数据和指向下一个节点的指针。
  - 链表的特点是可以动态分配内存，插入和删除操作的时间复杂度为 `O(1)`（在已知节点指针的情况下）。
  - 链表的缺点是访问元素的时间复杂度为 `O(n)`，因为需要从头节点开始遍历。

- **单向链表**：
  - 每个节点只有一个指针，指向下一个节点。
  - 单向链表只能从头节点开始遍历。

- **双向链表**：
  - 每个节点有两个指针，分别指向前一个节点和后一个节点。
  - 双向链表可以从头节点或尾节点开始遍历。

- **循环链表**：
  - 链表的最后一个节点的指针指向头节点，形成一个环。
  - 循环链表可以从任意节点开始遍历。

#### 链表的常见操作

- **插入**：
  - 在链表中插入一个新节点。
  - 时间复杂度为 `O(1)`（在已知节点指针的情况下）。

- **删除**：
  - 删除链表中的一个节点。
  - 时间复杂度为 `O(1)`（在已知节点指针的情况下）。

- **查找**：
  - 查找链表中的某个节点。
  - 时间复杂度为 `O(n)`。

- **遍历**：
  - 遍历链表中的所有节点。
  - 时间复杂度为 `O(n)`。

#### 链表与其他数据结构的比较

- **数组**：
  - 数组是连续的内存空间，访问元素的时间复杂度为 `O(1)`。
  - 数组的插入和删除操作的时间复杂度为 `O(n)`。

- **链表**：
  - 链表是非连续的内存空间，访问元素的时间复杂度为 `O(n)`。
  - 链表的插入和删除操作的时间复杂度为 `O(1)`（在已知节点指针的情况下）。

- **栈**：
  - 栈是一种后进先出（LIFO）的数据结构。
  - 栈的插入和删除操作的时间复杂度为 `O(1)`。

- **队列**：
  - 队列是一种先进先出（FIFO）的数据结构。
  - 队列的插入和删除操作的时间复杂度为 `O(1)`。

- **哈希表**：
  - 哈希表是一种通过哈希函数将键映射到值的数据结构。
  - 哈希表的插入、删除和查找操作的平均时间复杂度为 `O(1)`。

### 总结

通过暴力解法和递归法，可以在 `O(m + n)` 的时间复杂度内合并两个升序链表。暴力解法的空间复杂度为 `O(1)`，而递归法的空间复杂度为 `O(m + n)`。对于链表的操作，掌握其基本操作和特点，可以帮助更好地解决相关问题。
### 题目描述

给定一个非严格递增排列的数组 `nums`，请你原地删除重复出现的元素，使每个元素只出现一次，返回删除后数组的新长度。元素的相对顺序应该保持一致。然后返回 `nums` 中唯一元素的个数。

**示例**：
- 输入：`nums = [1,1,2]`
- 输出：`2, nums = [1,2,_]`
- 解释：函数应该返回新的长度 `2`，并且原数组 `nums` 的前两个元素被修改为 `1, 2`。不需要考虑数组中超出新长度后面的元素。

- 输入：`nums = [0,0,1,1,1,2,2,3,3,4]`
- 输出：`5, nums = [0,1,2,3,4]`
- 解释：函数应该返回新的长度 `5`，并且原数组 `nums` 的前五个元素被修改为 `0, 1, 2, 3, 4`。不需要考虑数组中超出新长度后面的元素。

### 我的答案

```cpp
int removeDuplicates(vector<int>& nums) {
    if (nums.empty()) return 0;

    int count = 1;
    int* p = nums.data();
    int* q = p + 1;

    while (q != nums.data() + nums.size()) {
        if (*p != *q) {
            p++;
            *p = *q;
            count++;
        }
        q++;
    }
  
    return count;
}
```

### 详细解释

这个算法的核心思想是通过双指针来原地删除数组中的重复元素。具体步骤如下：

1. **初始化**：
   - 如果 `nums` 为空，直接返回 `0`。
   - 定义两个指针 `p` 和 `q`，其中 `p` 指向当前不重复的元素，`q` 指向当前遍历的元素。
   - 初始化计数器 `count` 为 `1`，因为第一个元素一定是不重复的。

2. **遍历数组**：
   - 使用 `while` 循环遍历数组，直到 `q` 指针到达数组的末尾。
   - 每次比较 `*p` 和 `*q` 的值：
     - 如果 `*p != *q`，说明 `*q` 是一个新的不重复元素，将 `p` 指针向后移动一位，并将 `*q` 的值赋给 `*p`。然后增加计数器 `count`。
     - 如果 `*p == *q`，说明 `*q` 是重复元素，继续向后移动 `q` 指针。

3. **返回结果**：
   - 返回计数器 `count`，即不重复元素的数量。

**示例说明**：
- 对于输入 `nums = [1,1,2]`：
  - 初始时，`p` 指向 `1`，`q` 指向 `1`，`count = 1`。
  - 第一次比较，`*p == *q`，`q` 向后移动。
  - 第二次比较，`*p != *q`，将 `*q` 的值 `2` 赋给 `*p`，`p` 向后移动，`count = 2`。
  - 返回 `count = 2`，数组变为 `[1,2,_]`。

### 解题思路

#### 我的思路

- **双指针**：
  - 使用两个指针 `p` 和 `q`，分别指向当前不重复的元素和当前遍历的元素。
  - 通过比较 `*p` 和 `*q` 的值，将不重复的元素移动到正确的位置。
- **指针递增**：
  - `p` 指针只有在找到新的不重复元素时才递增。
  - `q` 指针每次循环都递增，用于遍历整个数组。
- **时间复杂度**：
  - 时间复杂度为 `O(n)`，因为每个元素最多被访问一次。
- **空间复杂度**：
  - 空间复杂度为 `O(1)`，只使用了常数级别的额外空间。

#### 标准解答1

**思路**：
- 使用一个辅助下标 `k`，记录尚未重复数的位置。
- 遍历数组，当发现 `nums[i] != nums[k]` 时，将 `nums[i]` 的值赋给 `nums[k+1]`，并将 `k` 递增。
- 最后返回 `k + 1`，即不重复元素的数量。

**时间复杂度**：
- 时间复杂度为 `O(n)`，因为每个元素最多被访问一次。

**空间复杂度**：
- 空间复杂度为 `O(1)`，只使用了常数级别的额外空间。

#### 标准解答2

**暴力解法**：
- 直接复制不重复的元素到一个新的数组中，然后返回新的数组。
- 时间复杂度为 `O(n)`，因为需要遍历整个数组。
- 空间复杂度为 `O(n)`，因为需要额外的数组来存储结果。

**优化**：
- 使用双指针法，原地修改数组，避免使用额外的空间。

#### 比较

- **时间复杂度**：我的答案和标准解答1的时间复杂度均为 `O(n)`。
- **空间复杂度**：我的答案和标准解答1的空间复杂度均为 `O(1)`。
- **无意义的比较**：我的答案和标准解答1都没有进行无意义的比较，每次比较都是必要的。

### 具体实现

#### 标准解答1的实现

```cpp
int removeDuplicates(vector<int>& nums) {
    if (nums.empty()) return 0;
  
    int k = 0;
    for (int i = 1; i < nums.size(); i++) {
        if (nums[i] != nums[k]) {
            k++;
            nums[k] = nums[i];
        }
    }
    return k + 1;
}
```

### 补充知识

#### 双指针

- **双指针**：
  - 双指针是一种常见的算法技巧，用于在数组或链表中解决问题。
  - 双指针通常用于需要同时遍历或处理数组或链表的多个位置的场景。
  - 双指针可以分为快慢指针、左右指针等。

- **快慢指针**：
  - 快慢指针通常用于链表问题，如检测链表中的环、找到链表的中点等。
  - 快指针每次移动两步，慢指针每次移动一步。

- **左右指针**：
  - 左右指针通常用于数组或字符串问题，如二分查找、反转数组、两数之和等。
  - 左指针从数组的起始位置开始，右指针从数组的末尾位置开始，向中间移动。

- **应用场景**：
  - **删除重复元素**：如本题所示，使用双指针来原地删除数组中的重复元素。
  - **链表操作**：如合并两个有序链表、检测链表中的环等。
  - **二分查找**：在有序数组中查找某个元素。
  - **反转数组**：使用左右指针来反转数组中的元素。
  - **两数之和**：在有序数组中查找两个数，使其和等于目标值。

#### 时间复杂度

- **时间复杂度**：
  - 时间复杂度是衡量算法运行时间随输入规模增长而增长的度量。
  - 常见的时间复杂度有 `O(1)`、`O(log n)`、`O(n)`、`O(n log n)`、`O(n^2)` 等。

#### 空间复杂度

- **空间复杂度**：
  - 空间复杂度是衡量算法所需额外空间随输入规模增长而增长的度量。
  - 常见的空间复杂度有 `O(1)`、`O(n)`、`O(n^2)` 等。

### 总结

通过双指针法，可以在 `O(n)` 的时间复杂度和 `O(1)` 的空间复杂度内删除有序数组中的重复元素。双指针法是一种高效的算法技巧，适用于多种场景。掌握双指针的基本思想和应用场景，可以帮助更好地解决相关问题。
### 题目描述

给定一个排序数组 `nums` 和一个目标值 `target`，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。

**要求**：必须使用时间复杂度为 `O(log n)` 的算法。

**示例**：

- 输入：`nums = [1,3,5,6]`, `target = 5`
- 输出：`2`
- 解释：`5` 出现在 `nums` 的索引 `2` 处。

- 输入：`nums = [1,3,5,6]`, `target = 2`
- 输出：`1`
- 解释：`2` 不在 `nums` 中，应插入到索引 `1` 处。

### 我的答案

```cpp
int searchInsert(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    int mid = 0;
    while (left <= right) {
        mid = left + (right - left) / 2;
        if (nums[mid] == target) return mid;
        else if (nums[mid] < target) left = mid + 1;
        else right = mid - 1;
    }

    return left;
}
```

### 详细解释

这个算法的核心思想是使用二分查找来在排序数组中找到目标值或确定其插入位置。具体步骤如下：

1. **初始化边界**：
   - 设置 `left` 为数组的起始索引 `0`，`right` 为数组的结束索引 `nums.size() - 1`。

2. **二分查找**：
   - 使用 `while` 循环进行二分查找，条件是 `left <= right`。
   - 计算中间索引 `mid = left + (right - left) / 2`，避免整数溢出。
   - 如果 `nums[mid] == target`，返回 `mid`。
   - 如果 `nums[mid] < target`，说明目标值在右半部分，更新 `left = mid + 1`。
   - 如果 `nums[mid] > target`，说明目标值在左半部分，更新 `right = mid - 1`。

3. **返回结果**：
   - 如果循环结束仍未找到目标值，返回 `left`，即目标值应插入的位置。

**示例说明**：
- 对于输入 `nums = [1,3,5,6]`, `target = 5`：
  - 初始时，`left = 0`, `right = 3`。
  - `mid = 1`，`nums[1] = 3 < 5`，更新 `left = 2`。
  - `mid = 2`，`nums[2] = 5 == 5`，返回 `2`。

- 对于输入 `nums = [1,3,5,6]`, `target = 2`：
  - 初始时，`left = 0`, `right = 3`。
  - `mid = 1`，`nums[1] = 3 > 2`，更新 `right = 0`。
  - `mid = 0`，`nums[0] = 1 < 2`，更新 `left = 1`。
  - `left > right`，返回 `1`。

### 解题思路

#### 我的思路

- **二分查找**：
  - 使用二分查找在排序数组中查找目标值或确定其插入位置。
  - 通过不断缩小搜索范围，最终确定目标值的位置或其应插入的位置。
- **时间复杂度**：
  - 时间复杂度为 `O(log n)`，因为每次查找将搜索范围减半。
- **空间复杂度**：
  - 空间复杂度为 `O(1)`，只使用了常数级别的额外空间。

#### 标准解答

**思路**：
- **二分查找**：
  - 使用标准的二分查找算法，在排序数组中查找目标值。
  - 如果找到目标值，返回其索引；否则返回应插入的位置。
- **时间复杂度**：
  - 时间复杂度为 `O(log n)`。
- **空间复杂度**：
  - 空间复杂度为 `O(1)`。

#### 比较

- **时间复杂度**：
  - 我的答案和标准解答的时间复杂度均为 `O(log n)`。
- **空间复杂度**：
  - 我的答案和标准解答的空间复杂度均为 `O(1)`。
- **无意义的比较**：
  - 我的答案和标准解答都没有进行无意义的比较操作。

### 具体实现

#### 标准解答的实现

```cpp
int searchInsert(vector<int>& nums, int target) {
    int left = 0, right = nums.size() - 1;
    while (left <= right) {
        int mid = left + (right - left) / 2;
        if (nums[mid] == target) return mid;
        else if (nums[mid] < target) left = mid + 1;
        else right = mid - 1;
    }
    return left;
}
```

### 补充知识

#### 二分查找

**二分查找**：
- 二分查找是一种在有序数组中查找目标值的算法。
- 通过不断将搜索范围减半，最终确定目标值的位置或其应插入的位置。

**步骤**：
1. **初始化边界**：
   - 设置 `left` 为数组的起始索引 `0`，`right` 为数组的结束索引 `nums.size() - 1`。

2. **二分查找**：
   - 使用 `while` 循环进行二分查找，条件是 `left <= right`。
   - 计算中间索引 `mid = left + (right - left) / 2`，避免整数溢出。
   - 如果 `nums[mid] == target`，返回 `mid`。
   - 如果 `nums[mid] < target`，说明目标值在右半部分，更新 `left = mid + 1`。
   - 如果 `nums[mid] > target`，说明目标值在左半部分，更新 `right = mid - 1`。

3. **返回结果**：
   - 如果循环结束仍未找到目标值，返回 `left`，即目标值应插入的位置。

**时间复杂度**：
- 时间复杂度为 `O(log n)`，因为每次查找将搜索范围减半。

**空间复杂度**：
- 空间复杂度为 `O(1)`，只使用了常数级别的额外空间。

#### 适用场景

当问题涉及以下条件时，可以考虑使用二分查找：
1. **有序数组**：
   - 数组必须是有序的，否则无法使用二分查找。
2. **查找目标值**：
   - 需要在数组中查找目标值或确定其插入位置。
3. **时间复杂度要求**：
   - 需要使用 `O(log n)` 的时间复杂度。

### 总结

通过二分查找算法，我们可以在 `O(log n)` 的时间复杂度内找到目标值或确定其插入位置。二分查找是一种高效的算法，适用于在有序数组中查找目标值的场景。掌握二分查找的基本思想和实现方法，可以帮助我们更好地解决相关问题。
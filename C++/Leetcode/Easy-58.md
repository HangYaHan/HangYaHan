### 题目描述

给定一个字符串 `s`，由若干单词组成，单词前后用一些空格字符隔开。返回字符串中最后一个单词的长度。

**单词** 是指仅由字母组成、不包含任何空格字符的最大子字符串。

**示例**：
- 输入：`s = "Hello World"`
- 输出：`5`
- 解释：最后一个单词是“World”，长度为 `5`。

- 输入：`s = "   fly me   to   the moon  "`
- 输出：`4`
- 解释：最后一个单词是“moon”，长度为 `4`。

- 输入：`s = "luffy is still joyboy"`
- 输出：`6`
- 解释：最后一个单词是长度为 `6` 的“joyboy”。

### 我的答案

```cpp
int lengthOfLastWord(string s) {
    int length = 0;
    int i = s.size() - 1;

    // Skip trailing spaces
    while (i >= 0 && s[i] == ' ') {
        i--;
    }

    // Count the length of the last word
    while (i >= 0 && s[i] != ' ') {
        length++;
        i--;
    }

    return length;
}
```

### 详细解释

这个算法的核心思想是从字符串的末尾开始，跳过末尾的空格，然后计算最后一个单词的长度。具体步骤如下：

1. **初始化**：
   - 定义一个变量 `length` 来记录最后一个单词的长度，初始值为 `0`。
   - 定义一个索引 `i`，初始值为 `s.size() - 1`，即字符串的最后一个字符的索引。

2. **跳过末尾的空格**：
   - 使用 `while` 循环从后向前遍历字符串，跳过末尾的空格字符。
   - 循环条件是 `i >= 0 && s[i] == ' '`，即索引 `i` 未越界且当前字符是空格。
   - 每次循环 `i` 递减，直到遇到第一个非空格字符。

3. **计算最后一个单词的长度**：
   - 使用另一个 `while` 循环从当前索引 `i` 开始，向前遍历字符串，计算最后一个单词的长度。
   - 循环条件是 `i >= 0 && s[i] != ' '`，即索引 `i` 未越界且当前字符不是空格。
   - 每次循环 `length` 递增，`i` 递减，直到遇到第一个空格字符或到达字符串的开头。

4. **返回结果**：
   - 返回 `length`，即最后一个单词的长度。

**示例说明**：
- 对于输入 `s = "Hello World"`：
  - 初始时，`i = 10`，`length = 0`。
  - 跳过末尾的空格：`i = 10`，`s[10]` 是空格，`i--`，`i = 9`。
  - 计算最后一个单词的长度：`s[9]` 是 'd'，`length = 1`，`i = 8`；`s[8]` 是 'l'，`length = 2`，`i = 7`；`s[7]` 是 'r'，`length = 3`，`i = 6`；`s[6]` 是 'o'，`length = 4`，`i = 5`；`s[5]` 是 'W'，`length = 5`，`i = 4`；`s[4]` 是空格，结束循环。
  - 返回 `length = 5`。

### 解题思路

#### 我的思路

- **从后向前遍历**：
  - 从字符串的末尾开始，跳过末尾的空格，然后计算最后一个单词的长度。
- **时间复杂度**：
  - 时间复杂度为 `O(n)`，其中 `n` 是字符串的长度。因为每个字符最多被访问两次（一次跳过空格，一次计算单词长度）。
- **空间复杂度**：
  - 空间复杂度为 `O(1)`，只使用了常数级别的额外空间。

#### 标准解答

**思路**：
- 标准解答与我的解答思路类似，都是从后向前遍历字符串，跳过末尾的空格，然后计算最后一个单词的长度。
- 标准解答的时间复杂度和空间复杂度与我的解答相同。

#### 比较

- **时间复杂度**：我的答案和标准解答的时间复杂度均为 `O(n)`。
- **空间复杂度**：我的答案和标准解答的空间复杂度均为 `O(1)`。
- **无意义的比较**：我的答案和标准解答都没有进行无意义的比较，每次比较都是必要的。

### 具体实现

#### 标准解答的实现

```cpp
int lengthOfLastWord(string s) {
    int length = 0;
    int i = s.size() - 1;

    // Skip trailing spaces
    while (i >= 0 && s[i] == ' ') {
        i--;
    }

    // Count the length of the last word
    while (i >= 0 && s[i] != ' ') {
        length++;
        i--;
    }

    return length;
}
```

### 补充知识

#### 字符串操作

- **字符串的基本操作**：
  - **访问字符**：可以使用索引 `s[i]` 来访问字符串 `s` 中的第 `i` 个字符。
  - **遍历字符串**：可以使用 `for` 循环或 `while` 循环来遍历字符串中的每个字符。
  - **字符串长度**：可以使用 `s.size()` 或 `s.length()` 来获取字符串的长度。
  - **字符串拼接**：可以使用 `+` 运算符或 `append()` 方法来拼接字符串。

- **字符串的常见问题**：
  - **查找子字符串**：可以使用 `find()` 方法来查找子字符串在字符串中的位置。
  - **替换子字符串**：可以使用 `replace()` 方法来替换字符串中的某个子字符串。
  - **分割字符串**：可以使用 `split()` 方法将字符串分割成多个子字符串。
  - **反转字符串**：可以使用 `reverse()` 方法来反转字符串中的字符。

#### 时间复杂度

- **时间复杂度**：
  - 时间复杂度是衡量算法运行时间随输入规模增长而增长的度量。
  - 常见的时间复杂度有 `O(1)`、`O(log n)`、`O(n)`、`O(n log n)`、`O(n^2)` 等。

#### 空间复杂度

- **空间复杂度**：
  - 空间复杂度是衡量算法所需额外空间随输入规模增长而增长的度量。
  - 常见的空间复杂度有 `O(1)`、`O(n)`、`O(n^2)` 等。

### 总结

通过从后向前遍历字符串，可以在 `O(n)` 的时间复杂度和 `O(1)` 的空间复杂度内计算字符串中最后一个单词的长度。掌握字符串的基本操作和常见问题的解决方法，可以帮助更好地解决相关问题。
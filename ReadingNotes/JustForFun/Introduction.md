# Chapter -- Introduction

## Words
**cultish**
意思是 “狂热崇拜的；类似邪教的”，常用来形容带有极端、盲目追捧性质的情况，例如：The cultish group followed their leader blindly.（那个狂热崇拜式的团体盲目地追随他们的领袖。）

**intricate**
词性为形容词，意思是 “错综复杂的；复杂精细的”，常用来描述事物的结构、设计、关系等很复杂，难以轻易理解或理清，比如：The watch has an intricate mechanism.（这块手表有着复杂精细的机械装置。）

**geek**
名词，原本常指 “反常的人；畸形人；（对电脑等技术、特定领域知识等）极客，呆子”，现在更多偏向指对某一领域（尤其是科技、电脑游戏等方面）有着浓厚兴趣、精通且痴迷的人，例如：He's a computer geek who spends hours coding every day.（他是个电脑极客，每天都花好几个小时写代码。）

**dunk-tank**
这是一个复合名词，直译为 “浸水坦克”，不过更常见的意思是 “（供娱乐用的） dunk tank 是一种游乐设施，一般是让人坐在高处，下面的人通过投中目标使座位翻转，让上面的人掉入水里，常出现在游乐场合或者活动中，例如：There was a dunk tank at the fair and many kids were eager to try it.（集市上有个浸水游乐设施，很多孩子都迫不及待地想试试。）

## Sentences
Suddenly it was infiltrating the corporate powerhouses controlling the planet.
突然，它（根据上下文确定具体指代对象, 这里应该是指Linux）正在渗入掌控着这个星球的企业巨头

## Likes
My heart was in my throat when he was growing up: How on Earth was he going to meet any nice girl that way? -- Anna Torvalds

Tbe open source philosophy bebind it all was simple: Information, in this case tbe source code or basic instructions bebind tbe operating system, sbould be free and freely shared for anyone interested in improving upon it, But those improvements should also be freely sbared. The same concept had supported centuries of scientifc discovery, Now it was finding a home in tbe corporate sphere, and it was possible to imagine its potential as a framework for creating tbe best of anytbing: a legal strategy, an opera.

Revolutionaries aren't born. Revolutionaries can't be planned. Revolutionaries can't be managed. And Revolutions happen... --David Diamond

And sometimes, revolutionaries just get stuck with it. --Linus Torvalds

## Comment
Linus, the founder of Linux and Git, initially I only knew Linux as an operating system, with little knowledge of Git. Not long ago, I learned how to use Git, and once mastered, I found it incredibly convenient and easy to use, bringing me a sense of unparalleled satisfaction. I firmly believe that such a tool should exist in this world, as it has largely solved many difficulties I encountered while coding during my undergraduate studies. Perhaps this also indicates that others have likely faced the same problems I encountered, and innovative ideas I came up with may have already been explored. Previously, I only knew about Linux and Linus as its creator; however, after using Git, I deeply appreciated its practicality and only realized later that it was also Linus's masterpiece. His remarkable talent and intelligence deeply impress me, prompting me to delve into this great figure through platforms like Bilibili. Many explanations mentioned Linus's autobiography, leading me to consider purchasing the English version of the book without hesitation, despite its high price. I view this decision as a source of motivation, driving me to complete the reading without regret.

"Git is my second big project, which is only created for me to maintain my first big project. and this is literally how i worked, i do code for fun, but i want to code for something meaningful." -- Linus Torvalds

After a semester of studying C++ and recently delving into its application in relevant projects, I would like to summarize my learning experience. My reflections align with the viewpoints of several bloggers I follow: essentially, C++ does not extend the underlying functionality of C, allowing tasks that C cannot accomplish to be achieved using C++; however, it indeed simplifies and streamlines life. Nevertheless, this assertion itself presents some dilemmas. Fundamentally, the operational mechanism of C language involves translating code into assembly language and then converting it into machine language. Clearly, pure assembly language or machine language represents the essence of a computer, possessing the ability to achieve virtually anything. Thus, C language itself can fulfill any function, and naturally, C++ does not offer anything additional. The core features of encapsulation, inheritance, polymorphism, and abstraction mentioned in textbooks essentially do not introduce any new functionalities; they resemble more of a set of rules, a programming ideology, or a method for designing class objects, all of which can be implemented using C language. This design thinking undeniably simplifies and eases life, which I find extremely beneficial. However, the learning curve of C++ is steep, with a vast array of concepts. Being an age-old language, multiple versions have been released since its inception, seemingly introducing a new standard every three years, possibly with the latest being C++23. Currently, my grasp is limited to the most fundamental and primitive aspects of C++, coupled with a lack of extensive enterprise practice, inevitably resulting in a superficial understanding of many issues. Or like what cherno said, just to make life easier and simpler.

"C language is designed at a time when compilers had to be simple, when language had to be kind of geared towards what the output was." -- Linus Torvalds